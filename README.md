刷题地址：
http://www.nowcoder.com/ta/coding-interviews?page=1

需要找到最优解法，参考学习牛客网**左程云**视频，牛客网算法讨论，《剑指offer》图书
需要手工敲出代码test然后在纸上写出代码来test对时间，空间复杂度需要理解test

---

# 1 二维数组中的查找
* 有序查找 二分

# 2 替换空格
* 先统计增大的空间，然后从后往前替换

# 3 从尾到头打印链表

* 头插法将链表反转一下，然后遍历（这种方式会改变链表的结构）

* 当链表只读时，采用递归的方法（栈）来操作，就可以实现链表数据的反转了 

# 4 重建二叉树
* 这类题目都采用递归，二叉树基本题

# 5 用两个栈实现队列
* 保持一个stack为空，通过两个栈转储，实现数据进出是队列形式的

# 6 旋转数组的最小数字

* 头尾往中间逼近的方法,直接遍历一遍，O(n)的做法，显然太low

* 二分查找的方法，不过有特殊情况，比如 [1 0 1 1 1] ，[1 1 1 0 1] 这种，需要单独顺序遍历

# 7 斐波那契数列

* 最直接的递归/动归， O(2^n), n的指数次方增长

* 利用变量,非递归，时间复杂度O(n)

* 快速幂的做法  f(n) = f(n - 1) + f(n - 2), 二阶的快速幂，时间复杂度O(logn),需要推算一下矩阵公式

# 8 跳台阶
# 9 变态跳台阶

* 与 斐波那契数列 解法类似

# 10 矩形覆盖
* 同 斐波那契数列

# 11 二进制中1的个数
* 经典问题，采用位运算

# 12 数值的整数次方

* 快速幂方法

* 边界, 符号， double/float判零问题

* 位运算比除法, 取模等效率高

# 13 调整数组顺序使奇数位于偶数前面 （？？）

* 注意无序和有序的区别

* 无序
	1. 快排思路，维持头，尾两个指针，不断的交换到相遇,时间O(n), 空间O(1)
* 要求保持数据相对位置不变

	1. 直接插入排序， 时间复杂度O(n^2), 空间复杂度O(1)
	2. 归并排序， 时间复杂度O(nlogn), 空间复杂度O(1)，归并排序是稳定的排序
	3. 利用复杂空间，空间复杂度O(n), 时间复杂度O(n)（直接遍历一遍）

# 14 链表中倒数第k个结点
* 两个指针，保持距离k,那么一个链表尾部，一个就是倒数k

# 15 反转链表

* 直接遍历，头插法

# 16 合并两个排序的链表

* 每个链表一个游标，边比较边连接，最后多的直接连接

* 递归思路，因为链表总是有序的，对两个链表头节点处理后，剩下的操作更前面的一样的

# 17 树的子结构 ??

* 注意 子结构 和 子树的区别

子树的意思是包含了一个结点，就得包含这个结点下的所有节点，一棵大小为n的二叉树有n个子树，就是分别以每个结点为根的子树。

子结构的意思是包含了一个结点，可以只取左子树或者右子树，或者都不取。


* 子树问题 可以采用 序列化方法，而子结构不能采用序列化方法

此题 递归求解，要么根，要么与左子树匹配，要么与右子树匹配,递归需要注意

# 18 二叉树的镜像

递归，注意顺序

# 19 顺时针打印矩阵

* 一圈一圈的打印，可以封装成一个方法

# 20 包含min函数的栈
* 维持两个栈，一个普通栈，一个存放min的栈，两个栈对应

# 21 栈的压入、弹出序列

* 直接利用STL stack等结构, 去模拟栈的压入、弹出过程

# 22 从上往下打印二叉树

直接层次遍历

# 23 二叉搜索树的后序遍历序列 
* 判断后续是否合法
* 问清楚有没有重复数字，搜索树是怎样的排序
* 根据后序：左 右 根的顺序，递归判断是否满足二叉树的大小关系

# 24 二叉树中和为某一值的路径

DFS 或 BFS

# 25 复杂链表的复制 ??

# 26 二叉搜索树与双向链表

* 二叉树的非递归遍历 ？

# 27 字符串的排列 
* 递归法，需要判断重复的串
* 可排序，然后判断，也可以采用set等数据结构
 
# 28 数组中出现次数超过一半的数字

* cur, count，（每次取两个不一样的数删除)　最后验证

# 29 最小的K个数

* 快排思路

* 堆排序思路 O(nlogk)时间复杂度，适合处理海量数据,采用红黑树（stl中的set,multiset都是基于红黑树的）

# 30 连续子数组的最大和

*动归

# 31 整数中1出现的次数（从1到n整数中1出现的次数） ？？

* 遍历1到n,对每个数采用mod 10 取得1的个数，时间复杂度达到O(nlogn)

* 找规律的方法，时间复杂度达到O(logn), 参考如下的讲解
http://blog.csdn.net/yi_afly/article/details/52012593

# 32 把数组排成最小的数
* 两两组合排序，注意0

# 33 丑数

# 34 第一个只出现一次的字符
 
* hash


# 35 数组中的逆序对 ？？

* 归并排序思路

# 36 两个链表的第一个公共结点 ？

* 单链表是否存在环
 走一步，走两步,进一步可以找到第一个公共节点

*直接利用map

* 将两个链表先处理成一样长的，然后再判断

# 37 数字在排序数组中出现的次数

* 二分查找，然后左右扩散开统计

# 38 二叉树的深度

* 递归

# 39 输入一棵二叉树，判断该二叉树是否是平衡二叉树

* 1 每个节点都采用求深度的方法，这样遍历求解，重复计算量太大

* 2 后序遍历，递归判断每个节点是否平衡，因为先访问了左右子树，后访问根，所以需要用变量保存每个节点的深度

# 40 数组中只出现一次的数字

* 利用数的性质，异或运算

# 41 和为S的连续正数序列

* 数学公式

# 42 和为S的两个数字

* 排序 + 二分查找

# 43 左旋转字符串 

* 三步翻转

* 改进三步翻转，用块交换


# 44 翻转单词顺序列

* 同 43 左旋转字符串 

# 45 扑克牌顺子 
* 统计个数为5，大小王个数
* 排序，逐一判断，减去大小王数目

# 46 孩子们的游戏(圆圈中最后剩下的数)

* 约瑟夫环

# 47 求1+2+3+...+n

# 48 不用加减乘除做加法
* 位运算模拟
 
# 49 把字符串转换成整数
* 注意最大负整数，最大正整数等特殊情况

# 50 数组中重复的数字 ？？

# 51 构建乘积数组

* 构建左部分乘积 和 右部分乘积序列
* 
# 52 正则表达式匹配 ？？

* 递归 ？，.

# 53 表示数值的字符串  ??


# 54 字符流中第一个不重复的字符


# 55 链表中环的入口结点

* 链表环的判断

# 56 删除链表中重复的结点

* 链表删除节点模拟, 注意各种特殊情况

# 57 二叉树的下一个结点， 中序遍历顺序的下一个结点并且返回 ？？


# 58 对称的二叉树

* 对称二叉树概念：将一棵二叉树沿着根节点对折，如果两棵子树完全重合（对称节点要么都为null，要么数据域完全相等），那么该二叉树是一个对称二叉树。

* 1 递归求解 相当于在判断root->left, root->right 两棵树 是否对折相等

* 2 非递归，用两个队列，维持root->left, root->right,节点入队列顺序不一样，判断完全

# 59 按之字形顺序打印二叉树
* 按照层次遍历，加上标记

# 60 把二叉树打印成多行

# 61 序列化二叉树

DFS 、BFS，要能反序列化

# 62 二叉搜索树的第k个结点

* 非递归遍历 查找

# 63 数据流中的中位数

# 64 滑动窗口的最大值
* 利用 stack

# 65 矩阵中的路径
* DFS

# 66 机器人的运动范围
* DFS

